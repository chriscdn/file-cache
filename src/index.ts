import path from "path";
import fs from "fs";
import { pathExists, pathExistsSync } from "path-exists";
import sha1 from "sha1";
import Semaphore from "@chriscdn/promise-semaphore";
import touch from "touch";
import { findNuke } from "@chriscdn/find-nuke";
import { Duration } from "@chriscdn/duration";
import { rimraf } from "rimraf";

const fsp = fs.promises;

type DirectoryPath = string;
type FilePath = string;
type Milliseconds = number;

export type FileCacheOptions<T extends Record<string, any>> = {
  cachePath: DirectoryPath;
  autoCreateCachePath?: boolean;
  cb: (filePath: FilePath, context: T, cache: FileCache<T>) => Promise<void>;
  ext: string;
  cleanupInterval?: Milliseconds;
  ttl: Milliseconds;
  // resolveFileName?: (args: T) => FilePath;
};

class FileCache<T extends Record<string, any>> {
  private _cachePath: FileCacheOptions<T>["cachePath"];
  // private _resolveFileName: FileCacheOptions<T>["resolveFileName"];
  private _cb: FileCacheOptions<T>["cb"];
  private _ext: FileCacheOptions<T>["ext"];
  private _ttl: FileCacheOptions<T>["ttl"];
  private _cleanupInterval: FileCacheOptions<T>["cleanupInterval"];

  private _intervalId: ReturnType<typeof setInterval> | null = null;

  private _semaphore: Semaphore = new Semaphore();
  private _cleanupSemaphore: Semaphore = new Semaphore();

  constructor(
    { cachePath, autoCreateCachePath, cb, ext, ttl, cleanupInterval }:
      FileCacheOptions<T>,
  ) {
    this._cachePath = cachePath;
    // this._resolveFileName = resolveFileName;
    this._cb = cb;
    this._ext = ext;
    this._ttl = ttl;
    this._cleanupInterval = cleanupInterval ??
      Duration.toMilliseconds({ days: 1 });

    (async () => {
      if (!(await pathExists(cachePath))) {
        throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.");
        // process.exit(1); // or throw new Error() if you want to let it bubble
      }
    })();

    if ((pathExistsSync(cachePath))) {
    } else if (autoCreateCachePath) {
      fs.mkdirSync(cachePath, { recursive: true });
    } else {
      throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.");
      // process.exit(1); // or throw new Error() if you want to let it bubble
    }

    // fire and forget
    this.cleanup();

    this._intervalId = setInterval(
      this.cleanup.bind(this),
      this._cleanupInterval,
    );
  }

  /**
   * Runs a cleanup pass to remove files older than 1 day from the cache.
   * This is called periodically, but can be triggered manually.
   */
  async cleanup() {
    try {
      await this._cleanupSemaphore.acquire();
      await findNuke(this._cachePath, {
        olderThan: this._ttl,
        verbose: true,
        deleteEmptyDirectories: true,
      });
    } finally {
      this._cleanupSemaphore.release();
    }
  }

  /**
   * Retrieves a cached file for the given arguments.
   * If the file doesn't exist, it is generated by the callback and stored.
   *
   * Concurrency-safe, ensuring no conflicts when multiple requests are made
   * for the same file.
   *
   * @param args The arguments used to determine the file's identity and generation
   * @returns The path to the cached or newly created file
   */
  async getFile(args: T): Promise<FilePath> {
    const filePath = this.resolveFilePath(args);

    try {
      await Promise.all([
        this._semaphore.acquire(filePath),
        this._cleanupSemaphore.wait(),
      ]);

      if (await pathExists(filePath)) {
        // fire and forget
        touch(filePath);
      } else {
        await fs.mkdirSync(path.dirname(filePath), { recursive: true });
        await this._cb(filePath, args, this);
      }
    } finally {
      this._semaphore.release(filePath);
    }

    return filePath;
  }

  async has(args: T): Promise<boolean> {
    const filePath = this.resolveFilePath(args);
    return await pathExists(filePath);
  }

  /**
   * Deletes a file from the cache if it exists.
   *
   * @param args The arguments used to determine the file's identity
   * @returns True if the file was deleted, false if it didn't exist
   */
  async expire(args: T): Promise<boolean> {
    const filePath = this.resolveFilePath(args);

    if (await pathExists(filePath)) {
      await rimraf(filePath);
      return true;
    } else {
      return false;
    }
  }

  /**
   * Stops the background cleanup process, but does not delete any cached files.
   */
  destroy() {
    if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }

  /**
   * Resolves the filename for the cache based on the provided arguments.
   *
   * Uses the provided `resolveFileName` function if available, or falls back to
   * generating a hash from the arguments to create a unique file name.
   */
  private resolveFileName(args: T): string {
    const baseName = sha1(JSON.stringify(args, Object.keys(args).sort()));

    return path.format({
      // dir: path.dirname(filePath),
      name: baseName,
      ext: this._ext,
    });

    // return this._resolveFileName
    //   ? this._resolveFileName(args)
    //   : `${sha1(JSON.stringify(args, Object.keys(args).sort()))}${this._ext}`;
  }

  /**
   * Resolves the full file path for the cached file based on the provided arguments.
   *
   * @param args The arguments used to resolve the file path
   * @returns The full path to the cached file
   */
  resolveFilePath(args: T): FilePath {
    const fileName = this.resolveFileName(args);

    const filePath = path.resolve(
      this._cachePath,
      fileName[0],
      fileName[1],
      fileName[2],
      // fileName[3],
      fileName,
    );

    return filePath;
  }

  async resolveCreateFilePath(args: T): Promise<FilePath> {
    const filePath = this.resolveFilePath(args);

    await fsp.mkdir(path.dirname(filePath), { recursive: true });

    return filePath;
  }
}

export { type DirectoryPath, FileCache, type FilePath };
