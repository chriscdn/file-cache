import path from "path";
import fs from "fs";
import { pathExists, pathExistsSync } from "path-exists";
import sha1 from "sha1";
import { GroupSemaphore, Semaphore } from "@chriscdn/promise-semaphore";
import touch from "touch";
import { findNuke } from "@chriscdn/find-nuke";
import { Duration } from "@chriscdn/duration";

import { Memoize } from "@chriscdn/memoize";

const fsp = fs.promises;

type DirectoryPath = string;
type FilePath = string;
type Milliseconds = number;

const deleteFile = async (filepath: FilePath) =>
  await fs.promises.unlink(filepath);

export type FileCacheOptions<T extends Record<string, any>> = {
  cachePath: DirectoryPath;
  autoCreateCachePath?: boolean;
  cb: (filePath: FilePath, args: T, cache: FileCache<T>) => Promise<void>;
  ext: (args: T) => string | Promise<string>;
  resolveCacheFileKey?: (args: T) => string | Promise<string>;
  ttl: Milliseconds;
  cleanupInterval?: Milliseconds;
};

class FileCache<T extends Record<string, any>> {
  private _cachePath: FileCacheOptions<T>["cachePath"];

  private _cb: FileCacheOptions<T>["cb"];

  private _ttl: FileCacheOptions<T>["ttl"];
  private _cleanupInterval: FileCacheOptions<T>["cleanupInterval"];

  private _resolveCacheFileKey: Required<
    FileCacheOptions<T>
  >["resolveCacheFileKey"];
  private _ext: FileCacheOptions<T>["ext"];

  private _intervalId: ReturnType<typeof setInterval> | null = null;

  private _semaphore: Semaphore = new Semaphore();
  private _cleanupGroupSemaphore: GroupSemaphore = new GroupSemaphore();

  // private _fileNameResover(args:T) =>

  constructor(
    {
      cachePath,
      autoCreateCachePath,
      cb,
      ext,
      ttl,
      cleanupInterval,
      resolveCacheFileKey,
    }: FileCacheOptions<T>,
  ) {
    this._cachePath = cachePath;
    this._cb = cb;
    this._ext = ext;
    this._ttl = ttl;
    this._cleanupInterval = cleanupInterval ??
      Duration.toMilliseconds({ days: 1 });

    this._resolveCacheFileKey = resolveCacheFileKey ??
      ((args: T) => sha1(JSON.stringify(args)));

    if ((pathExistsSync(cachePath))) {
      // we're good
    } else if (autoCreateCachePath) {
      fs.mkdirSync(cachePath, { recursive: true });
    } else {
      throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.");
    }

    // fire and forget
    this.cleanup();

    this._intervalId = setInterval(
      this.cleanup.bind(this),
      this._cleanupInterval,
    );

    this.resolveFileName = Memoize(this.resolveFileName.bind(this));
    this.resolveFilePath = Memoize(this.resolveFilePath.bind(this));
  }

  /**
   * Runs a cleanup pass to remove files older than 1 day from the cache.
   * This is called periodically, but can be triggered manually.
   */
  async cleanup() {
    try {
      await this._cleanupGroupSemaphore.acquire("cleanup");
      await findNuke(this._cachePath, {
        olderThan: this._ttl,
        verbose: true,
        deleteEmptyDirectories: true,
      });
    } finally {
      this._cleanupGroupSemaphore.release("cleanup");
    }
  }

  /**
   * Retrieves a cached file for the given arguments.
   * If the file doesn't exist, it is generated by the callback and stored.
   *
   * Concurrency-safe, ensuring no conflicts when multiple requests are made
   * for the same file.
   *
   * @param args The arguments used to determine the file's identity and generation
   * @returns The path to the cached or newly created file
   */
  async getFile(args: T): Promise<FilePath> {
    const filePath = await this.resolveFilePath(args);

    try {
      // await this._cleanupGroupSemaphore.acquire("thumbnail");
      // await this._semaphore.acquire(filePath);

      await Promise.all([
        this._cleanupGroupSemaphore.acquire("getFile"),
        this._semaphore.acquire(filePath),
      ]);

      if (await pathExists(filePath)) {
        // fire and forget
        touch(filePath);
      } else {
        await fsp.mkdir(path.dirname(filePath), { recursive: true });
        await this._cb(filePath, args, this);
      }
    } finally {
      this._semaphore.release(filePath);
      this._cleanupGroupSemaphore.release("getFile");
    }

    return filePath;
  }

  async has(args: T): Promise<boolean> {
    const filePath = await this.resolveFilePath(args);
    return await pathExists(filePath);
  }

  /**
   * Deletes a file from the cache if it exists.
   *
   * @param args The arguments used to determine the file's identity
   * @returns True if the file was deleted, false if it didn't exist
   */
  async expire(args: T): Promise<boolean> {
    const filePath = await this.resolveFilePath(args);

    try {
      await Promise.all([
        this._cleanupGroupSemaphore.acquire("expire"),
        this._semaphore.acquire(filePath),
      ]);

      if (await pathExists(filePath)) {
        await deleteFile(filePath);
        return true;
      } else {
        return false;
      }
    } finally {
      this._semaphore.release(filePath);
      this._cleanupGroupSemaphore.release("expire");
    }
  }

  /**
   * Stops the background cleanup process, but does not delete any cached files.
   */
  destroy() {
    if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }

  /**
   * Resolves the filename for the cache based on the provided arguments.
   *
   * Uses the provided `resolveFileName` function if available, or falls back to
   * generating a hash from the arguments to create a unique file name.
   */
  private async resolveFileName(args: T): Promise<string> {
    const [name, ext] = await Promise.all([
      this._resolveCacheFileKey(args),
      this._ext(args),
    ]);

    return path.format({
      name,
      ext,
    });
  }

  /**
   * Resolves the full file path for the cached file based on the provided arguments.
   *
   * @param args The arguments used to resolve the file path
   * @returns The full path to the cached file
   */
  async resolveFilePath(args: T): Promise<FilePath> {
    const fileName = await this.resolveFileName(args);

    const filePath = path.resolve(
      this._cachePath,
      fileName[0],
      fileName[1],
      fileName[2],
      // fileName[3],
      fileName,
    );

    return filePath;
  }
}

export { type DirectoryPath, FileCache, type FilePath };
