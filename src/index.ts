import path from "path";
import fs from "fs";
import { pathExists, pathExistsSync } from "path-exists";
import sha1 from "sha1";
import Semaphore from "@chriscdn/promise-semaphore";
import touch from "touch";
import { findNuke } from "@chriscdn/find-nuke";
import { Duration } from "@chriscdn/duration";
import { rimraf } from "rimraf";
import { Memoize } from "@chriscdn/memoize";
const fsp = fs.promises;

type DirectoryPath = string;
type FilePath = string;
type Milliseconds = number;

export type FileCacheOptions<T extends Record<string, any>> = {
  cachePath: DirectoryPath;
  autoCreateCachePath?: boolean;
  cb: (filePath: FilePath, context: T, cache: FileCache<T>) => Promise<void>;
  ext: (context: T) => string | Promise<string>;
  ttl: Milliseconds;
  cleanupInterval?: Milliseconds;
};

class FileCache<T extends Record<string, any>> {
  private _cachePath: FileCacheOptions<T>["cachePath"];

  private _cb: FileCacheOptions<T>["cb"];
  private _ext: FileCacheOptions<T>["ext"];
  private _ttl: FileCacheOptions<T>["ttl"];
  private _cleanupInterval: FileCacheOptions<T>["cleanupInterval"];

  private _intervalId: ReturnType<typeof setInterval> | null = null;

  private _semaphore: Semaphore = new Semaphore();
  private _cleanupSemaphore: Semaphore = new Semaphore();

  constructor(
    { cachePath, autoCreateCachePath, cb, ext, ttl, cleanupInterval }:
      FileCacheOptions<T>,
  ) {
    this._cachePath = cachePath;
    this._cb = cb;
    this._ext = ext;
    this._ttl = ttl;
    this._cleanupInterval = cleanupInterval ??
      Duration.toMilliseconds({ days: 1 });

    if ((pathExistsSync(cachePath))) {
      // we're good
    } else if (autoCreateCachePath) {
      fs.mkdirSync(cachePath, { recursive: true });
    } else {
      throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.");
    }

    // fire and forget
    this.cleanup();

    this._intervalId = setInterval(
      this.cleanup.bind(this),
      this._cleanupInterval,
    );

    this.resolveFileName = Memoize(this.resolveFileName.bind(this));
    this.resolveFilePath = Memoize(this.resolveFilePath.bind(this));
  }

  /**
   * Runs a cleanup pass to remove files older than 1 day from the cache.
   * This is called periodically, but can be triggered manually.
   */
  async cleanup() {
    try {
      await this._cleanupSemaphore.acquire();
      await findNuke(this._cachePath, {
        olderThan: this._ttl,
        verbose: true,
        deleteEmptyDirectories: true,
      });
    } finally {
      this._cleanupSemaphore.release();
    }
  }

  /**
   * Retrieves a cached file for the given arguments.
   * If the file doesn't exist, it is generated by the callback and stored.
   *
   * Concurrency-safe, ensuring no conflicts when multiple requests are made
   * for the same file.
   *
   * @param args The arguments used to determine the file's identity and generation
   * @returns The path to the cached or newly created file
   */
  async getFile(args: T): Promise<FilePath> {
    const filePath = await this.resolveFilePath(args);

    try {
      await Promise.all([
        this._semaphore.acquire(filePath),
        this._cleanupSemaphore.wait(), // wait for any cleanup task to end
      ]);

      if (await pathExists(filePath)) {
        // fire and forget
        touch(filePath);
      } else {
        await fsp.mkdir(path.dirname(filePath), { recursive: true });
        await this._cb(filePath, args, this);
      }
    } finally {
      this._semaphore.release(filePath);
    }

    return filePath;
  }

  async has(args: T): Promise<boolean> {
    const filePath = await this.resolveFilePath(args);
    return await pathExists(filePath);
  }

  /**
   * Deletes a file from the cache if it exists.
   *
   * @param args The arguments used to determine the file's identity
   * @returns True if the file was deleted, false if it didn't exist
   */
  async expire(args: T): Promise<boolean> {
    const filePath = await this.resolveFilePath(args);

    try {
      await this._semaphore.acquire(filePath);

      if (await pathExists(filePath)) {
        await rimraf(filePath);
        return true;
      } else {
        return false;
      }
    } finally {
      this._semaphore.release(filePath);
    }
  }

  /**
   * Stops the background cleanup process, but does not delete any cached files.
   */
  destroy() {
    if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }

  /**
   * Resolves the filename for the cache based on the provided arguments.
   *
   * Uses the provided `resolveFileName` function if available, or falls back to
   * generating a hash from the arguments to create a unique file name.
   */
  private async resolveFileName(args: T): Promise<string> {
    const baseName = sha1(JSON.stringify(args));

    return path.format({
      name: baseName,
      ext: await this._ext(args),
    });
  }

  /**
   * Resolves the full file path for the cached file based on the provided arguments.
   *
   * @param args The arguments used to resolve the file path
   * @returns The full path to the cached file
   */
  async resolveFilePath(args: T): Promise<FilePath> {
    const fileName = await this.resolveFileName(args);

    const filePath = path.resolve(
      this._cachePath,
      fileName[0],
      fileName[1],
      fileName[2],
      // fileName[3],
      fileName,
    );

    return filePath;
  }

  // async resolveCreateFilePath(args: T): Promise<FilePath> {
  //   const filePath = this.resolveFilePath(args);

  //   await fsp.mkdir(path.dirname(filePath), { recursive: true });

  //   return filePath;
  // }
}

export { type DirectoryPath, FileCache, type FilePath };
