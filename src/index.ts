import path from "path";
import fs from "fs";
import { pathExists, pathExistsSync } from "path-exists";
import sha1 from "sha1";
import { GroupSemaphore, Semaphore } from "@chriscdn/promise-semaphore";
import touch from "touch";
import { findNuke } from "@chriscdn/find-nuke";
import { Duration } from "@chriscdn/duration";

type DirectoryPath = string;
type FileName = string;
type FilePath = string;
type Milliseconds = number;

export type FileCacheOptions<T extends Record<string, any>> = {
  cachePath: DirectoryPath;
  autoCreateCachePath?: boolean;
  cb: (filePath: FilePath, args: T, cache: FileCache<T>) => Promise<void>;
  ext: (args: T) => string | Promise<string>;
  resolveCacheKey?: (args: T) => string | Promise<string>;
  ttl: Milliseconds;
  cleanupInterval?: Milliseconds;
};

class FileCache<T extends Record<string, any>> {
  private _cachePath: FileCacheOptions<T>["cachePath"];
  private _cb: FileCacheOptions<T>["cb"];
  private _ttl: FileCacheOptions<T>["ttl"];
  private _cleanupInterval: FileCacheOptions<T>["cleanupInterval"];
  private _resolveCacheKey: Required<
    FileCacheOptions<T>
  >["resolveCacheKey"];
  private _ext: FileCacheOptions<T>["ext"];
  private _intervalId: ReturnType<typeof setInterval> | null = null;
  private _semaphore: Semaphore = new Semaphore();
  private _cleanupGroupSemaphore: GroupSemaphore = new GroupSemaphore();

  constructor(
    {
      cachePath,
      autoCreateCachePath,
      cb,
      ext,
      ttl,
      cleanupInterval,
      resolveCacheKey,
    }: FileCacheOptions<T>,
  ) {
    this._cachePath = cachePath;
    this._cb = cb;
    this._ext = ext;
    this._ttl = ttl;
    this._cleanupInterval = cleanupInterval ??
      Duration.toMilliseconds({ days: 1 });

    this._resolveCacheKey = resolveCacheKey ??
      ((args: T) => (JSON.stringify(args)));

    // Startup code
    if ((pathExistsSync(cachePath))) {
      // we're good
    } else if (autoCreateCachePath) {
      fs.mkdirSync(cachePath, { recursive: true });
    } else {
      throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.");
    }

    // fire and forget
    this.cleanup();

    this._intervalId = setInterval(
      this.cleanup.bind(this),
      this._cleanupInterval,
    );
  }

  /**
   * Resolves the filename for the cache based on the provided arguments.
   *
   * Uses the provided `resolveFileName` function if available, or falls back to
   * generating a hash from the arguments to create a unique file name.
   */
  private async resolveFileName(args: T): Promise<FileName> {
    const [name, ext] = await Promise.all([
      this._resolveCacheKey(args),
      this._ext(args),
    ]);

    const resolvedFileName = sha1(JSON.stringify([name, ext]));

    return path.format({
      name: resolvedFileName,
      ext,
    }) as FileName;
  }

  /**
   * Retrieves a cached file for the given arguments.
   * If the file doesn't exist, it is generated by the callback and stored.
   *
   * Concurrency-safe, ensuring no conflicts when multiple requests are made
   * for the same file.
   *
   * @param args The arguments used to determine the file's identity and generation
   * @returns The path to the cached or newly created file
   */
  async getFile(args: T): Promise<FilePath> {
    const filePath = await this.resolveFilePath(args);

    try {
      await Promise.all([
        this._cleanupGroupSemaphore.acquire("getFile"),
        this._semaphore.acquire(filePath),
      ]);

      if (await pathExists(filePath)) {
        // fire and forget
        touch(filePath);
      } else {
        await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
        await this._cb(filePath, args, this);
      }
    } finally {
      this._semaphore.release(filePath);
      this._cleanupGroupSemaphore.release("getFile");
    }

    return filePath;
  }

  /**
   * Resolves the full file path for the cached file based on the provided arguments.
   *
   * @param args The arguments used to resolve the file path
   * @returns The full path to the cached file
   */
  async resolveFilePath(args: T): Promise<FilePath> {
    const fileName = await this.resolveFileName(args);

    const filePath = path.resolve(
      this._cachePath,
      fileName[0]!,
      fileName[1]!,
      fileName[2]!,
      fileName,
    );

    return filePath;
  }

  /**
   * Stops the background cleanup process, but does not delete any cached files.
   */
  destroy() {
    if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }

  async has(args: T): Promise<boolean> {
    const filePath = await this.resolveFilePath(args);
    return await pathExists(filePath);
  }

  /**
   * Runs a cleanup pass to remove files older than 1 day from the cache.
   * This is called periodically, but can be triggered manually.
   */
  async cleanup() {
    try {
      await this._cleanupGroupSemaphore.acquire("cleanup");
      await findNuke(this._cachePath, {
        olderThan: this._ttl,
        verbose: true,
        deleteEmptyDirectories: true,
      });
    } finally {
      this._cleanupGroupSemaphore.release("cleanup");
    }
  }
}

export { type DirectoryPath, FileCache, type FileName, type FilePath };
