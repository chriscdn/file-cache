import path from 'path';
import fs from 'fs';
import { pathExistsSync, pathExists } from 'path-exists';
import sha1 from 'sha1';
import { Semaphore, GroupSemaphore } from '@chriscdn/promise-semaphore';
import touch from 'touch';
import { findNuke } from '@chriscdn/find-nuke';
import { Duration } from '@chriscdn/duration';

class FileCache {
  constructor({
    cachePath,
    autoCreateCachePath,
    cb,
    ext,
    ttl,
    cleanupInterval,
    resolveCacheKey
  }) {
    this._cachePath = void 0;
    this._cb = void 0;
    this._ttl = void 0;
    this._cleanupInterval = void 0;
    this._resolveCacheKey = void 0;
    this._ext = void 0;
    this._intervalId = null;
    this._semaphore = new Semaphore();
    this._cleanupGroupSemaphore = new GroupSemaphore();
    this._cachePath = cachePath;
    this._cb = cb;
    this._ext = ext;
    this._ttl = ttl;
    this._cleanupInterval = cleanupInterval != null ? cleanupInterval : Duration.toMilliseconds({
      days: 1
    });
    this._resolveCacheKey = resolveCacheKey != null ? resolveCacheKey : args => JSON.stringify(args);
    // Startup code
    if (pathExistsSync(cachePath)) ; else if (autoCreateCachePath) {
      fs.mkdirSync(cachePath, {
        recursive: true
      });
    } else {
      throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.");
    }
    // fire and forget
    this.cleanup();
    this._intervalId = setInterval(this.cleanup.bind(this), this._cleanupInterval);
  }
  /**
   * Resolves the filename for the cache based on the provided arguments.
   *
   * Uses the provided `resolveFileName` function if available, or falls back to
   * generating a hash from the arguments to create a unique file name.
   */
  async resolveFileName(args) {
    const [name, ext] = await Promise.all([this._resolveCacheKey(args), this._ext(args)]);
    const resolvedFileName = sha1(JSON.stringify([name, ext]));
    return path.format({
      name: resolvedFileName,
      ext
    });
  }
  /**
   * Retrieves a cached file for the given arguments.
   * If the file doesn't exist, it is generated by the callback and stored.
   *
   * Concurrency-safe, ensuring no conflicts when multiple requests are made
   * for the same file.
   *
   * @param args The arguments used to determine the file's identity and generation
   * @returns The path to the cached or newly created file
   */
  async getFile(args) {
    const filePath = await this.resolveFilePath(args);
    try {
      await Promise.all([this._cleanupGroupSemaphore.acquire("getFile"), this._semaphore.acquire(filePath)]);
      if (await pathExists(filePath)) {
        // fire and forget
        touch(filePath);
      } else {
        await fs.promises.mkdir(path.dirname(filePath), {
          recursive: true
        });
        await this._cb(filePath, args, this);
      }
    } finally {
      this._semaphore.release(filePath);
      this._cleanupGroupSemaphore.release("getFile");
    }
    return filePath;
  }
  /**
   * Resolves the full file path for the cached file based on the provided arguments.
   *
   * @param args The arguments used to resolve the file path
   * @returns The full path to the cached file
   */
  async resolveFilePath(args) {
    const fileName = await this.resolveFileName(args);
    const filePath = path.resolve(this._cachePath, fileName[0], fileName[1], fileName[2], fileName);
    return filePath;
  }
  /**
   * Stops the background cleanup process, but does not delete any cached files.
   */
  destroy() {
    if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }
  async has(args) {
    const filePath = await this.resolveFilePath(args);
    return await pathExists(filePath);
  }
  /**
   * Runs a cleanup pass to remove files older than 1 day from the cache.
   * This is called periodically, but can be triggered manually.
   */
  async cleanup() {
    try {
      await this._cleanupGroupSemaphore.acquire("cleanup");
      await findNuke(this._cachePath, {
        olderThan: this._ttl,
        verbose: true,
        deleteEmptyDirectories: true
      });
    } finally {
      this._cleanupGroupSemaphore.release("cleanup");
    }
  }
}

export { FileCache };
//# sourceMappingURL=file-cache.module.js.map
