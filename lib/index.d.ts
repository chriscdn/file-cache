type DirectoryPath = string;
type FilePath = string;
type Milliseconds = number;
export type FileCacheOptions<T extends Record<string, any>> = {
    cachePath: DirectoryPath;
    autoCreateCachePath?: boolean;
    cb: (filePath: FilePath, args: T, cache: FileCache<T>) => Promise<void>;
    ext: (args: T) => string | Promise<string>;
    resolveCacheFileKey?: (args: T) => string | Promise<string>;
    ttl: Milliseconds;
    cleanupInterval?: Milliseconds;
};
declare class FileCache<T extends Record<string, any>> {
    private _cachePath;
    private _cb;
    private _ttl;
    private _cleanupInterval;
    private _resolveCacheFileKey;
    private _ext;
    private _intervalId;
    private _semaphore;
    private _cleanupGroupSemaphore;
    constructor({ cachePath, autoCreateCachePath, cb, ext, ttl, cleanupInterval, resolveCacheFileKey, }: FileCacheOptions<T>);
    /**
     * Runs a cleanup pass to remove files older than 1 day from the cache.
     * This is called periodically, but can be triggered manually.
     */
    cleanup(): Promise<void>;
    /**
     * Retrieves a cached file for the given arguments.
     * If the file doesn't exist, it is generated by the callback and stored.
     *
     * Concurrency-safe, ensuring no conflicts when multiple requests are made
     * for the same file.
     *
     * @param args The arguments used to determine the file's identity and generation
     * @returns The path to the cached or newly created file
     */
    getFile(args: T): Promise<FilePath>;
    has(args: T): Promise<boolean>;
    /**
     * Deletes a file from the cache if it exists.
     *
     * @param args The arguments used to determine the file's identity
     * @returns True if the file was deleted, false if it didn't exist
     */
    expire(args: T): Promise<boolean>;
    /**
     * Stops the background cleanup process, but does not delete any cached files.
     */
    destroy(): void;
    /**
     * Resolves the filename for the cache based on the provided arguments.
     *
     * Uses the provided `resolveFileName` function if available, or falls back to
     * generating a hash from the arguments to create a unique file name.
     */
    private resolveFileName;
    /**
     * Resolves the full file path for the cached file based on the provided arguments.
     *
     * @param args The arguments used to resolve the file path
     * @returns The full path to the cached file
     */
    resolveFilePath(args: T): Promise<FilePath>;
}
export { type DirectoryPath, FileCache, type FilePath };
