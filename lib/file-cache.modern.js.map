{"version":3,"file":"file-cache.modern.js","sources":["../src/index.ts"],"sourcesContent":["import path from \"path\";\nimport { promises as fs } from \"fs\";\nimport { pathExists } from \"path-exists\";\nimport sha1 from \"sha1\";\nimport Semaphore from \"@chriscdn/promise-semaphore\";\nimport touch from \"touch\";\nimport { findNuke } from \"@chriscdn/find-nuke\";\nimport { Duration } from \"@chriscdn/duration\";\nimport { rimraf } from \"rimraf\";\n\ntype DirectoryPath = string;\ntype FilePath = string;\ntype Milliseconds = number;\n\nexport type FileCacheOptions<T extends Record<string, any>> = {\n  cachePath: DirectoryPath;\n  cb: (filePath: FilePath, context: T) => Promise<void>;\n  ext: string;\n  cleanupInterval?: Milliseconds;\n  ttl: Milliseconds;\n  resolveFileName?: (args: T) => FilePath;\n};\n\nclass FileCache<T> {\n  private _cachePath: FileCacheOptions<T>[\"cachePath\"];\n  private _resolveFileName: FileCacheOptions<T>[\"resolveFileName\"];\n  private _cb: FileCacheOptions<T>[\"cb\"];\n  private _ext: FileCacheOptions<T>[\"ext\"];\n  private _ttl: FileCacheOptions<T>[\"ttl\"];\n  private _cleanupInterval: FileCacheOptions<T>[\"cleanupInterval\"];\n\n  private _intervalId: ReturnType<typeof setInterval> | null = null;\n\n  private _semaphore: Semaphore = new Semaphore();\n  private _cleanupSemaphore: Semaphore = new Semaphore();\n\n  constructor(\n    { cachePath, resolveFileName, cb, ext, ttl, cleanupInterval }:\n      FileCacheOptions<T>,\n  ) {\n    this._cachePath = cachePath;\n    this._resolveFileName = resolveFileName;\n    this._cb = cb;\n    this._ext = ext;\n    this._ttl = ttl;\n    this._cleanupInterval = cleanupInterval ??\n      Duration.toMilliseconds({ days: 1 });\n\n    (async () => {\n      if (!(await pathExists(this._cachePath))) {\n        throw new Error(\"ðŸ’¥ FileCache error: cachePath does not exist.\");\n        // process.exit(1); // or throw new Error() if you want to let it bubble\n      }\n    })();\n\n    // fire and forget\n    this.cleanup();\n\n    this._intervalId = setInterval(\n      this.cleanup.bind(this),\n      this._cleanupInterval,\n    );\n  }\n\n  /**\n   * Runs a cleanup pass to remove files older than 1 day from the cache.\n   * This is called periodically, but can be triggered manually.\n   */\n  async cleanup() {\n    try {\n      await this._cleanupSemaphore.acquire();\n      await findNuke(this._cachePath, {\n        olderThan: this._ttl,\n        verbose: true,\n        deleteEmptyDirectories: true,\n      });\n    } finally {\n      this._cleanupSemaphore.release();\n    }\n  }\n\n  /**\n   * Retrieves a cached file for the given arguments.\n   * If the file doesn't exist, it is generated by the callback and stored.\n   *\n   * Concurrency-safe, ensuring no conflicts when multiple requests are made\n   * for the same file.\n   *\n   * @param args The arguments used to determine the file's identity and generation\n   * @returns The path to the cached or newly created file\n   */\n  async getFile(args: T): Promise<FilePath> {\n    const filePath = this.resolveFilePath(args);\n\n    try {\n      await Promise.all([\n        this._semaphore.acquire(filePath),\n        this._cleanupSemaphore.wait(),\n      ]);\n\n      if (await pathExists(filePath)) {\n        // fire and forget\n        touch(filePath);\n      } else {\n        await fs.mkdir(path.dirname(filePath), { recursive: true });\n        await this._cb(filePath, args);\n      }\n    } finally {\n      this._semaphore.release(filePath);\n    }\n\n    return filePath;\n  }\n\n  /**\n   * Deletes a file from the cache if it exists.\n   *\n   * @param args The arguments used to determine the file's identity\n   * @returns True if the file was deleted, false if it didn't exist\n   */\n  async expire(args: T): Promise<boolean> {\n    const filePath = this.resolveFilePath(args);\n\n    if (await pathExists(filePath)) {\n      await rimraf(filePath);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Stops the background cleanup process, but does not delete any cached files.\n   */\n  destroy() {\n    if (this._intervalId) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n  }\n\n  /**\n   * Resolves the filename for the cache based on the provided arguments.\n   *\n   * Uses the provided `resolveFileName` function if available, or falls back to\n   * generating a hash from the arguments to create a unique file name.\n   */\n  private resolveFileName(args: T): string {\n    return this._resolveFileName\n      ? this._resolveFileName(args)\n      : `${sha1(JSON.stringify(args, Object.keys(args).sort()))}.${this._ext}`;\n  }\n\n  /**\n   * Resolves the full file path for the cached file based on the provided arguments.\n   *\n   * @param args The arguments used to resolve the file path\n   * @returns The full path to the cached file\n   */\n  private resolveFilePath(args: T): FilePath {\n    const fileName = this.resolveFileName(args);\n\n    const filePath = path.resolve(\n      this._cachePath,\n      fileName[0],\n      fileName[1],\n      fileName[2],\n      fileName[3],\n      fileName,\n    );\n\n    return filePath;\n  }\n}\n\nexport { FileCache };\n"],"names":["FileCache","constructor","cachePath","resolveFileName","cb","ext","ttl","cleanupInterval","_this","_cachePath","_resolveFileName","_cb","_ext","_ttl","_cleanupInterval","_intervalId","_semaphore","Semaphore","_cleanupSemaphore","this","Duration","toMilliseconds","days","pathExists","Error","cleanup","setInterval","bind","acquire","findNuke","olderThan","verbose","deleteEmptyDirectories","release","getFile","args","filePath","resolveFilePath","Promise","all","wait","touch","fs","mkdir","path","dirname","recursive","expire","rimraf","destroy","clearInterval","sha1","JSON","stringify","Object","keys","sort","fileName","resolve"],"mappings":"4SAuBA,MAAMA,EAaJC,WAAAA,EACEC,UAAEA,EAASC,gBAAEA,EAAeC,GAAEA,EAAEC,IAAEA,EAAGC,IAAEA,EAAGC,gBAAEA,IACvBC,IAAAA,EAdfC,KAAAA,KAAAA,gBACAC,EAAAA,KAAAA,sBACAC,EAAAA,KAAAA,SACAC,EAAAA,KAAAA,UACAC,EAAAA,KAAAA,UACAC,EAAAA,KAAAA,sBAEAC,EAAAA,KAAAA,YAAqD,KAErDC,KAAAA,WAAwB,IAAIC,OAC5BC,kBAA+B,IAAID,EAMzCE,KAAKV,WAAaP,EAClBiB,KAAKT,iBAAmBP,EACxBgB,KAAKR,IAAMP,EACXe,KAAKP,KAAOP,EACZc,KAAKN,KAAOP,EACZa,KAAKL,iBAAkC,MAAfP,EAAAA,EACtBa,EAASC,eAAe,CAAEC,KAAM,IAElC,iBACE,UAAYC,EAAWf,EAAKC,YAC1B,MAAM,IAAIe,MAAM,gDAGnB,CALD,GAQAL,KAAKM,UAELN,KAAKJ,YAAcW,YACjBP,KAAKM,QAAQE,KAAKR,MAClBA,KAAKL,iBAET,CAMA,aAAMW,GACJ,UACYN,KAACD,kBAAkBU,gBACvBC,EAASV,KAAKV,WAAY,CAC9BqB,UAAWX,KAAKN,KAChBkB,SAAS,EACTC,wBAAwB,GAE5B,CAAC,QACCb,KAAKD,kBAAkBe,SACzB,CACF,CAYA,aAAMC,CAAQC,GACZ,MAAMC,EAAWjB,KAAKkB,gBAAgBF,GAEtC,UACQG,QAAQC,IAAI,CAChBpB,KAAKH,WAAWY,QAAQQ,GACxBjB,KAAKD,kBAAkBsB,eAGfjB,EAAWa,GAEnBK,EAAML,UAEAM,EAAGC,MAAMC,EAAKC,QAAQT,GAAW,CAAEU,WAAW,UAC9C3B,KAAKR,IAAIyB,EAAUD,GAE7B,CAAC,QACChB,KAAKH,WAAWiB,QAAQG,EAC1B,CAEA,OAAOA,CACT,CAQA,YAAMW,CAAOZ,GACX,MAAMC,EAAWjB,KAAKkB,gBAAgBF,GAEtC,cAAUZ,EAAWa,WACbY,EAAOZ,IAEf,EAGF,CAKAa,OAAAA,GACM9B,KAAKJ,cACPmC,cAAc/B,KAAKJ,aACnBI,KAAKJ,YAAc,KAEvB,CAQQZ,eAAAA,CAAgBgC,GACtB,OAAOhB,KAAKT,iBACRS,KAAKT,iBAAiByB,GACtB,GAAGgB,EAAKC,KAAKC,UAAUlB,EAAMmB,OAAOC,KAAKpB,GAAMqB,YAAYrC,KAAKP,MACtE,CAQQyB,eAAAA,CAAgBF,GACtB,MAAMsB,EAAWtC,KAAKhB,gBAAgBgC,GAWtC,OATiBS,EAAKc,QACpBvC,KAAKV,WACLgD,EAAS,GACTA,EAAS,GACTA,EAAS,GACTA,EAAS,GACTA,EAIJ"}