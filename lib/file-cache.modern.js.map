{"version":3,"file":"file-cache.modern.js","sources":["../src/index.ts"],"sourcesContent":["import path from \"path\";\nimport fs from \"fs\";\nimport { pathExists, pathExistsSync } from \"path-exists\";\nimport sha1 from \"sha1\";\nimport { GroupSemaphore, Semaphore } from \"@chriscdn/promise-semaphore\";\nimport touch from \"touch\";\nimport { findNuke } from \"@chriscdn/find-nuke\";\nimport { Duration } from \"@chriscdn/duration\";\n\ntype DirectoryPath = string;\ntype FileName = string;\ntype FilePath = string;\ntype Milliseconds = number;\n\nexport type FileCacheOptions<T extends Record<string, any>> = {\n  cachePath: DirectoryPath;\n  autoCreateCachePath?: boolean;\n  cb: (filePath: FilePath, args: T, cache: FileCache<T>) => Promise<void>;\n  ext: (args: T) => string | Promise<string>;\n  resolveCacheKey?: (args: T) => string | Promise<string>;\n  ttl: Milliseconds;\n  cleanupInterval?: Milliseconds;\n};\n\nclass FileCache<T extends Record<string, any>> {\n  private _cachePath: FileCacheOptions<T>[\"cachePath\"];\n  private _cb: FileCacheOptions<T>[\"cb\"];\n  private _ttl: FileCacheOptions<T>[\"ttl\"];\n  private _cleanupInterval: FileCacheOptions<T>[\"cleanupInterval\"];\n  private _resolveCacheKey: Required<\n    FileCacheOptions<T>\n  >[\"resolveCacheKey\"];\n  private _ext: FileCacheOptions<T>[\"ext\"];\n  private _intervalId: ReturnType<typeof setInterval> | null = null;\n  private _semaphore: Semaphore = new Semaphore();\n  private _cleanupGroupSemaphore: GroupSemaphore = new GroupSemaphore();\n\n  constructor(\n    {\n      cachePath,\n      autoCreateCachePath,\n      cb,\n      ext,\n      ttl,\n      cleanupInterval,\n      resolveCacheKey,\n    }: FileCacheOptions<T>,\n  ) {\n    this._cachePath = cachePath;\n    this._cb = cb;\n    this._ext = ext;\n    this._ttl = ttl;\n    this._cleanupInterval = cleanupInterval ??\n      Duration.toMilliseconds({ days: 1 });\n\n    this._resolveCacheKey = resolveCacheKey ??\n      ((args: T) => (JSON.stringify(args)));\n\n    // Startup code\n    if ((pathExistsSync(cachePath))) {\n      // we're good\n    } else if (autoCreateCachePath) {\n      fs.mkdirSync(cachePath, { recursive: true });\n    } else {\n      throw new Error(\"ðŸ’¥ FileCache error: cachePath does not exist.\");\n    }\n\n    // fire and forget\n    this.cleanup();\n\n    this._intervalId = setInterval(\n      this.cleanup.bind(this),\n      this._cleanupInterval,\n    );\n  }\n\n  /**\n   * Resolves the filename for the cache based on the provided arguments.\n   *\n   * Uses the provided `resolveFileName` function if available, or falls back to\n   * generating a hash from the arguments to create a unique file name.\n   */\n  private async resolveFileName(args: T): Promise<FileName> {\n    const [name, ext] = await Promise.all([\n      this._resolveCacheKey(args),\n      this._ext(args),\n    ]);\n\n    const resolvedFileName = sha1(JSON.stringify([name, ext]));\n\n    return path.format({\n      name: resolvedFileName,\n      ext,\n    }) as FileName;\n  }\n\n  /**\n   * Retrieves a cached file for the given arguments.\n   * If the file doesn't exist, it is generated by the callback and stored.\n   *\n   * Concurrency-safe, ensuring no conflicts when multiple requests are made\n   * for the same file.\n   *\n   * @param args The arguments used to determine the file's identity and generation\n   * @returns The path to the cached or newly created file\n   */\n  async getFile(args: T): Promise<FilePath> {\n    const filePath = await this.resolveFilePath(args);\n\n    try {\n      await Promise.all([\n        this._cleanupGroupSemaphore.acquire(\"getFile\"),\n        this._semaphore.acquire(filePath),\n      ]);\n\n      if (await pathExists(filePath)) {\n        // fire and forget\n        touch(filePath);\n      } else {\n        await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n        await this._cb(filePath, args, this);\n      }\n    } finally {\n      this._semaphore.release(filePath);\n      this._cleanupGroupSemaphore.release(\"getFile\");\n    }\n\n    return filePath;\n  }\n\n  /**\n   * Resolves the full file path for the cached file based on the provided arguments.\n   *\n   * @param args The arguments used to resolve the file path\n   * @returns The full path to the cached file\n   */\n  async resolveFilePath(args: T): Promise<FilePath> {\n    const fileName = await this.resolveFileName(args);\n\n    const filePath = path.resolve(\n      this._cachePath,\n      fileName[0],\n      fileName[1],\n      fileName[2],\n      fileName,\n    );\n\n    return filePath;\n  }\n\n  /**\n   * Stops the background cleanup process, but does not delete any cached files.\n   */\n  destroy() {\n    if (this._intervalId) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n  }\n\n  async has(args: T): Promise<boolean> {\n    const filePath = await this.resolveFilePath(args);\n    return await pathExists(filePath);\n  }\n\n  /**\n   * Runs a cleanup pass to remove files older than 1 day from the cache.\n   * This is called periodically, but can be triggered manually.\n   */\n  async cleanup() {\n    try {\n      await this._cleanupGroupSemaphore.acquire(\"cleanup\");\n      await findNuke(this._cachePath, {\n        olderThan: this._ttl,\n        verbose: true,\n        deleteEmptyDirectories: true,\n      });\n    } finally {\n      this._cleanupGroupSemaphore.release(\"cleanup\");\n    }\n  }\n}\n\nexport { type DirectoryPath, FileCache, type FileName, type FilePath };\n"],"names":["FileCache","constructor","cachePath","autoCreateCachePath","cb","ext","ttl","cleanupInterval","resolveCacheKey","_cachePath","_cb","_ttl","_cleanupInterval","_resolveCacheKey","_ext","_intervalId","_semaphore","Semaphore","_cleanupGroupSemaphore","GroupSemaphore","Duration","toMilliseconds","days","args","JSON","stringify","pathExistsSync","fs","mkdirSync","recursive","Error","cleanup","setInterval","bind","resolveFileName","name","Promise","all","resolvedFileName","sha1","path","format","getFile","filePath","resolveFilePath","acquire","pathExists","touch","promises","mkdir","dirname","release","fileName","resolve","destroy","clearInterval","has","findNuke","olderThan","verbose","deleteEmptyDirectories"],"mappings":"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"}