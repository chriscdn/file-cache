// src/index.ts
import path from "path";
import fs from "fs";
import { pathExists, pathExistsSync } from "path-exists";
import sha1 from "sha1";
import { GroupSemaphore, Semaphore } from "@chriscdn/promise-semaphore";
import touch from "touch";
import { findNuke } from "@chriscdn/find-nuke";
import { Duration } from "@chriscdn/duration";
var FileCache = class {
  _cachePath;
  _cb;
  _ttl;
  _cleanupInterval;
  _resolveCacheKey;
  _ext;
  _intervalId = null;
  _semaphore = new Semaphore();
  _cleanupGroupSemaphore = new GroupSemaphore();
  constructor({
    cachePath,
    autoCreateCachePath,
    cb,
    ext,
    ttl,
    cleanupInterval,
    resolveCacheKey
  }) {
    this._cachePath = cachePath;
    this._cb = cb;
    this._ext = ext;
    this._ttl = ttl;
    this._cleanupInterval = cleanupInterval ?? Duration.toMilliseconds({ days: 1 });
    this._resolveCacheKey = resolveCacheKey ?? ((args) => JSON.stringify(args));
    if (pathExistsSync(cachePath)) {
    } else if (autoCreateCachePath) {
      fs.mkdirSync(cachePath, { recursive: true });
    } else {
      throw new Error("\u{1F4A5} FileCache error: cachePath does not exist.");
    }
    this.cleanup();
    this._intervalId = setInterval(
      this.cleanup.bind(this),
      this._cleanupInterval
    );
  }
  /**
   * Resolves the filename for the cache based on the provided arguments.
   *
   * Uses the provided `resolveFileName` function if available, or falls back to
   * generating a hash from the arguments to create a unique file name.
   */
  async resolveFileName(args) {
    const [name, ext] = await Promise.all([
      this._resolveCacheKey(args),
      this._ext(args)
    ]);
    const resolvedFileName = sha1(JSON.stringify([name, ext]));
    return path.format({
      name: resolvedFileName,
      ext
    });
  }
  /**
   * Retrieves a cached file for the given arguments.
   * If the file doesn't exist, it is generated by the callback and stored.
   *
   * Concurrency-safe, ensuring no conflicts when multiple requests are made
   * for the same file.
   *
   * @param args The arguments used to determine the file's identity and generation
   * @returns The path to the cached or newly created file
   */
  async getFile(args) {
    const filePath = await this.resolveFilePath(args);
    try {
      await Promise.all([
        this._cleanupGroupSemaphore.acquire("getFile"),
        this._semaphore.acquire(filePath)
      ]);
      if (await pathExists(filePath)) {
        touch(filePath);
      } else {
        await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
        await this._cb(filePath, args, this);
      }
    } finally {
      this._semaphore.release(filePath);
      this._cleanupGroupSemaphore.release("getFile");
    }
    return filePath;
  }
  /**
   * Resolves the full file path for the cached file based on the provided arguments.
   *
   * @param args The arguments used to resolve the file path
   * @returns The full path to the cached file
   */
  async resolveFilePath(args) {
    const fileName = await this.resolveFileName(args);
    const filePath = path.resolve(
      this._cachePath,
      fileName[0],
      fileName[1],
      fileName[2],
      fileName
    );
    return filePath;
  }
  /**
   * Stops the background cleanup process, but does not delete any cached files.
   */
  destroy() {
    if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }
  async has(args) {
    const filePath = await this.resolveFilePath(args);
    return await pathExists(filePath);
  }
  /**
   * Runs a cleanup pass to remove files older than 1 day from the cache.
   * This is called periodically, but can be triggered manually.
   */
  async cleanup() {
    try {
      await this._cleanupGroupSemaphore.acquire("cleanup");
      await findNuke(this._cachePath, {
        olderThan: this._ttl,
        verbose: true,
        deleteEmptyDirectories: true
      });
    } finally {
      this._cleanupGroupSemaphore.release("cleanup");
    }
  }
};
export {
  FileCache
};
//# sourceMappingURL=index.js.map