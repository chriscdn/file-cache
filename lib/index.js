import path from "path";
import fs from "fs";
import { pathExists, pathExistsSync } from "path-exists";
import sha1 from "sha1";
import Semaphore from "@chriscdn/promise-semaphore";
import touch from "touch";
import { findNuke } from "@chriscdn/find-nuke";
import { Duration } from "@chriscdn/duration";
import { rimraf } from "rimraf";
import { Memoize } from "@chriscdn/memoize";
const fsp = fs.promises;
class FileCache {
    _cachePath;
    _cb;
    _ttl;
    _cleanupInterval;
    _resolveCacheFileKey;
    _ext;
    _intervalId = null;
    _semaphore = new Semaphore();
    _cleanupSemaphore = new Semaphore();
    // private _fileNameResover(args:T) =>
    constructor({ cachePath, autoCreateCachePath, cb, ext, ttl, cleanupInterval, resolveCacheFileKey, }) {
        this._cachePath = cachePath;
        this._cb = cb;
        this._ext = ext;
        this._ttl = ttl;
        this._cleanupInterval = cleanupInterval ??
            Duration.toMilliseconds({ days: 1 });
        this._resolveCacheFileKey = resolveCacheFileKey ??
            ((args) => sha1(JSON.stringify(args)));
        if ((pathExistsSync(cachePath))) {
            // we're good
        }
        else if (autoCreateCachePath) {
            fs.mkdirSync(cachePath, { recursive: true });
        }
        else {
            throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.");
        }
        // fire and forget
        this.cleanup();
        this._intervalId = setInterval(this.cleanup.bind(this), this._cleanupInterval);
        this.resolveFileName = Memoize(this.resolveFileName.bind(this));
        this.resolveFilePath = Memoize(this.resolveFilePath.bind(this));
    }
    /**
     * Runs a cleanup pass to remove files older than 1 day from the cache.
     * This is called periodically, but can be triggered manually.
     */
    async cleanup() {
        try {
            await this._cleanupSemaphore.acquire();
            await findNuke(this._cachePath, {
                olderThan: this._ttl,
                verbose: true,
                deleteEmptyDirectories: true,
            });
        }
        finally {
            this._cleanupSemaphore.release();
        }
    }
    /**
     * Retrieves a cached file for the given arguments.
     * If the file doesn't exist, it is generated by the callback and stored.
     *
     * Concurrency-safe, ensuring no conflicts when multiple requests are made
     * for the same file.
     *
     * @param args The arguments used to determine the file's identity and generation
     * @returns The path to the cached or newly created file
     */
    async getFile(args) {
        const filePath = await this.resolveFilePath(args);
        try {
            await Promise.all([
                this._semaphore.acquire(filePath),
                this._cleanupSemaphore.wait(), // wait for any cleanup task to end
            ]);
            if (await pathExists(filePath)) {
                // fire and forget
                touch(filePath);
            }
            else {
                await fsp.mkdir(path.dirname(filePath), { recursive: true });
                await this._cb(filePath, args, this);
            }
        }
        finally {
            this._semaphore.release(filePath);
        }
        return filePath;
    }
    async has(args) {
        const filePath = await this.resolveFilePath(args);
        return await pathExists(filePath);
    }
    /**
     * Deletes a file from the cache if it exists.
     *
     * @param args The arguments used to determine the file's identity
     * @returns True if the file was deleted, false if it didn't exist
     */
    async expire(args) {
        const filePath = await this.resolveFilePath(args);
        try {
            await this._semaphore.acquire(filePath);
            if (await pathExists(filePath)) {
                await rimraf(filePath);
                return true;
            }
            else {
                return false;
            }
        }
        finally {
            this._semaphore.release(filePath);
        }
    }
    /**
     * Stops the background cleanup process, but does not delete any cached files.
     */
    destroy() {
        if (this._intervalId) {
            clearInterval(this._intervalId);
            this._intervalId = null;
        }
    }
    /**
     * Resolves the filename for the cache based on the provided arguments.
     *
     * Uses the provided `resolveFileName` function if available, or falls back to
     * generating a hash from the arguments to create a unique file name.
     */
    async resolveFileName(args) {
        const [name, ext] = await Promise.all([
            this._resolveCacheFileKey(args),
            this._ext(args),
        ]);
        return path.format({
            name,
            ext,
        });
    }
    /**
     * Resolves the full file path for the cached file based on the provided arguments.
     *
     * @param args The arguments used to resolve the file path
     * @returns The full path to the cached file
     */
    async resolveFilePath(args) {
        const fileName = await this.resolveFileName(args);
        const filePath = path.resolve(this._cachePath, fileName[0], fileName[1], fileName[2], 
        // fileName[3],
        fileName);
        return filePath;
    }
}
export { FileCache };
//# sourceMappingURL=index.js.map