import e from"path";import{promises as t}from"fs";import{pathExists as i}from"path-exists";import a from"sha1";import r from"@chriscdn/promise-semaphore";import s from"touch";import{findNuke as h}from"@chriscdn/find-nuke";import{Duration as l}from"@chriscdn/duration";import{rimraf as o}from"rimraf";class n{constructor({cachePath:e,resolveFileName:t,cb:a,ext:s,ttl:h,cleanupInterval:o}){var n=this;this._cachePath=void 0,this._resolveFileName=void 0,this._cb=void 0,this._ext=void 0,this._ttl=void 0,this._cleanupInterval=void 0,this._intervalId=null,this._semaphore=new r,this._cleanupSemaphore=new r,this._cachePath=e,this._resolveFileName=t,this._cb=a,this._ext=s,this._ttl=h,this._cleanupInterval=null!=o?o:l.toMilliseconds({days:1}),async function(){if(!await i(n._cachePath))throw new Error("ðŸ’¥ FileCache error: cachePath does not exist.")}(),this.cleanup(),this._intervalId=setInterval(this.cleanup.bind(this),this._cleanupInterval)}async cleanup(){try{await this._cleanupSemaphore.acquire(),await h(this._cachePath,{olderThan:this._ttl,verbose:!0,deleteEmptyDirectories:!0})}finally{this._cleanupSemaphore.release()}}async getFile(a){const r=this.resolveFilePath(a);try{await Promise.all([this._semaphore.acquire(r),this._cleanupSemaphore.wait()]),await i(r)?s(r):(await t.mkdir(e.dirname(r),{recursive:!0}),await this._cb(r,a))}finally{this._semaphore.release(r)}return r}async expire(e){const t=this.resolveFilePath(e);return!!await i(t)&&(await o(t),!0)}destroy(){this._intervalId&&(clearInterval(this._intervalId),this._intervalId=null)}resolveFileName(e){return this._resolveFileName?this._resolveFileName(e):`${a(JSON.stringify(e,Object.keys(e).sort()))}.${this._ext}`}resolveFilePath(t){const i=this.resolveFileName(t);return e.resolve(this._cachePath,i[0],i[1],i[2],i[3],i)}}export{n as FileCache};
//# sourceMappingURL=file-cache.modern.js.map
