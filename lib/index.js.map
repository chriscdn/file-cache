{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import path from \"path\";\nimport fs from \"fs\";\nimport { pathExists, pathExistsSync } from \"path-exists\";\nimport sha1 from \"sha1\";\nimport Semaphore from \"@chriscdn/promise-semaphore\";\nimport touch from \"touch\";\nimport { findNuke } from \"@chriscdn/find-nuke\";\nimport { Duration } from \"@chriscdn/duration\";\nimport { rimraf } from \"rimraf\";\n\nconst fsp = fs.promises;\n\ntype DirectoryPath = string;\ntype FilePath = string;\ntype Milliseconds = number;\n\nexport type FileCacheOptions<T extends Record<string, any>> = {\n  cachePath: DirectoryPath;\n  autoCreateCachePath?: boolean;\n  cb: (filePath: FilePath, context: T, cache: FileCache<T>) => Promise<void>;\n  ext: string;\n  cleanupInterval?: Milliseconds;\n  ttl: Milliseconds;\n  // resolveFileName?: (args: T) => FilePath;\n};\n\nclass FileCache<T extends Record<string, any>> {\n  private _cachePath: FileCacheOptions<T>[\"cachePath\"];\n  // private _resolveFileName: FileCacheOptions<T>[\"resolveFileName\"];\n  private _cb: FileCacheOptions<T>[\"cb\"];\n  private _ext: FileCacheOptions<T>[\"ext\"];\n  private _ttl: FileCacheOptions<T>[\"ttl\"];\n  private _cleanupInterval: FileCacheOptions<T>[\"cleanupInterval\"];\n\n  private _intervalId: ReturnType<typeof setInterval> | null = null;\n\n  private _semaphore: Semaphore = new Semaphore();\n  private _cleanupSemaphore: Semaphore = new Semaphore();\n\n  constructor(\n    { cachePath, autoCreateCachePath, cb, ext, ttl, cleanupInterval }:\n      FileCacheOptions<T>,\n  ) {\n    this._cachePath = cachePath;\n    // this._resolveFileName = resolveFileName;\n    this._cb = cb;\n    this._ext = ext;\n    this._ttl = ttl;\n    this._cleanupInterval = cleanupInterval ??\n      Duration.toMilliseconds({ days: 1 });\n\n    (async () => {\n      if (!(await pathExists(cachePath))) {\n        throw new Error(\"\uD83D\uDCA5 FileCache error: cachePath does not exist.\");\n        // process.exit(1); // or throw new Error() if you want to let it bubble\n      }\n    })();\n\n    if ((pathExistsSync(cachePath))) {\n    } else if (autoCreateCachePath) {\n      fs.mkdirSync(cachePath, { recursive: true });\n    } else {\n      throw new Error(\"\uD83D\uDCA5 FileCache error: cachePath does not exist.\");\n      // process.exit(1); // or throw new Error() if you want to let it bubble\n    }\n\n    // fire and forget\n    this.cleanup();\n\n    this._intervalId = setInterval(\n      this.cleanup.bind(this),\n      this._cleanupInterval,\n    );\n  }\n\n  /**\n   * Runs a cleanup pass to remove files older than 1 day from the cache.\n   * This is called periodically, but can be triggered manually.\n   */\n  async cleanup() {\n    try {\n      await this._cleanupSemaphore.acquire();\n      await findNuke(this._cachePath, {\n        olderThan: this._ttl,\n        verbose: true,\n        deleteEmptyDirectories: true,\n      });\n    } finally {\n      this._cleanupSemaphore.release();\n    }\n  }\n\n  /**\n   * Retrieves a cached file for the given arguments.\n   * If the file doesn't exist, it is generated by the callback and stored.\n   *\n   * Concurrency-safe, ensuring no conflicts when multiple requests are made\n   * for the same file.\n   *\n   * @param args The arguments used to determine the file's identity and generation\n   * @returns The path to the cached or newly created file\n   */\n  async getFile(args: T): Promise<FilePath> {\n    const filePath = this.resolveFilePath(args);\n\n    try {\n      await Promise.all([\n        this._semaphore.acquire(filePath),\n        this._cleanupSemaphore.wait(),\n      ]);\n\n      if (await pathExists(filePath)) {\n        // fire and forget\n        touch(filePath);\n      } else {\n        await fs.mkdirSync(path.dirname(filePath), { recursive: true });\n        await this._cb(filePath, args, this);\n      }\n    } finally {\n      this._semaphore.release(filePath);\n    }\n\n    return filePath;\n  }\n\n  async has(args: T): Promise<boolean> {\n    const filePath = this.resolveFilePath(args);\n    return await pathExists(filePath);\n  }\n\n  /**\n   * Deletes a file from the cache if it exists.\n   *\n   * @param args The arguments used to determine the file's identity\n   * @returns True if the file was deleted, false if it didn't exist\n   */\n  async expire(args: T): Promise<boolean> {\n    const filePath = this.resolveFilePath(args);\n\n    if (await pathExists(filePath)) {\n      await rimraf(filePath);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Stops the background cleanup process, but does not delete any cached files.\n   */\n  destroy() {\n    if (this._intervalId) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n  }\n\n  /**\n   * Resolves the filename for the cache based on the provided arguments.\n   *\n   * Uses the provided `resolveFileName` function if available, or falls back to\n   * generating a hash from the arguments to create a unique file name.\n   */\n  private resolveFileName(args: T): string {\n    const baseName = sha1(JSON.stringify(args, Object.keys(args).sort()));\n\n    return path.format({\n      // dir: path.dirname(filePath),\n      name: baseName,\n      ext: this._ext,\n    });\n\n    // return this._resolveFileName\n    //   ? this._resolveFileName(args)\n    //   : `${sha1(JSON.stringify(args, Object.keys(args).sort()))}${this._ext}`;\n  }\n\n  /**\n   * Resolves the full file path for the cached file based on the provided arguments.\n   *\n   * @param args The arguments used to resolve the file path\n   * @returns The full path to the cached file\n   */\n  resolveFilePath(args: T): FilePath {\n    const fileName = this.resolveFileName(args);\n\n    const filePath = path.resolve(\n      this._cachePath,\n      fileName[0],\n      fileName[1],\n      fileName[2],\n      // fileName[3],\n      fileName,\n    );\n\n    return filePath;\n  }\n\n  async resolveCreateFilePath(args: T): Promise<FilePath> {\n    const filePath = this.resolveFilePath(args);\n\n    await fsp.mkdir(path.dirname(filePath), { recursive: true });\n\n    return filePath;\n  }\n}\n\nexport { type DirectoryPath, FileCache, type FilePath };\n"],
  "mappings": "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",
  "names": []
}
