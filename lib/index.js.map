{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import path from \"path\";\nimport fs from \"fs\";\nimport { pathExists, pathExistsSync } from \"path-exists\";\nimport sha1 from \"sha1\";\nimport { GroupSemaphore, Semaphore } from \"@chriscdn/promise-semaphore\";\nimport touch from \"touch\";\nimport { findNuke } from \"@chriscdn/find-nuke\";\nimport { Duration } from \"@chriscdn/duration\";\n\ntype DirectoryPath = string;\ntype FileName = string;\ntype FilePath = string;\ntype Milliseconds = number;\n\nexport type FileCacheOptions<T extends Record<string, any>> = {\n  cachePath: DirectoryPath;\n  autoCreateCachePath?: boolean;\n  cb: (filePath: FilePath, args: T, cache: FileCache<T>) => Promise<void>;\n  ext: (args: T) => string | Promise<string>;\n  resolveCacheKey?: (args: T) => string | Promise<string>;\n  ttl: Milliseconds;\n  cleanupInterval?: Milliseconds;\n};\n\nclass FileCache<T extends Record<string, any>> {\n  private _cachePath: FileCacheOptions<T>[\"cachePath\"];\n  private _cb: FileCacheOptions<T>[\"cb\"];\n  private _ttl: FileCacheOptions<T>[\"ttl\"];\n  private _cleanupInterval: FileCacheOptions<T>[\"cleanupInterval\"];\n  private _resolveCacheKey: Required<\n    FileCacheOptions<T>\n  >[\"resolveCacheKey\"];\n  private _ext: FileCacheOptions<T>[\"ext\"];\n  private _intervalId: ReturnType<typeof setInterval> | null = null;\n  private _semaphore: Semaphore = new Semaphore();\n  private _cleanupGroupSemaphore: GroupSemaphore = new GroupSemaphore();\n\n  constructor(\n    {\n      cachePath,\n      autoCreateCachePath,\n      cb,\n      ext,\n      ttl,\n      cleanupInterval,\n      resolveCacheKey,\n    }: FileCacheOptions<T>,\n  ) {\n    this._cachePath = cachePath;\n    this._cb = cb;\n    this._ext = ext;\n    this._ttl = ttl;\n    this._cleanupInterval = cleanupInterval ??\n      Duration.toMilliseconds({ days: 1 });\n\n    this._resolveCacheKey = resolveCacheKey ??\n      ((args: T) => (JSON.stringify(args)));\n\n    // Startup code\n    if ((pathExistsSync(cachePath))) {\n      // we're good\n    } else if (autoCreateCachePath) {\n      fs.mkdirSync(cachePath, { recursive: true });\n    } else {\n      throw new Error(\"ðŸ’¥ FileCache error: cachePath does not exist.\");\n    }\n\n    // fire and forget\n    this.cleanup();\n\n    this._intervalId = setInterval(\n      this.cleanup.bind(this),\n      this._cleanupInterval,\n    );\n  }\n\n  /**\n   * Resolves the filename for the cache based on the provided arguments.\n   *\n   * Uses the provided `resolveFileName` function if available, or falls back to\n   * generating a hash from the arguments to create a unique file name.\n   */\n  private async resolveFileName(args: T): Promise<FileName> {\n    const [name, ext] = await Promise.all([\n      this._resolveCacheKey(args),\n      this._ext(args),\n    ]);\n\n    const resolvedFileName = sha1(JSON.stringify([name, ext]));\n\n    return path.format({\n      name: resolvedFileName,\n      ext,\n    }) as FileName;\n  }\n\n  /**\n   * Retrieves a cached file for the given arguments.\n   * If the file doesn't exist, it is generated by the callback and stored.\n   *\n   * Concurrency-safe, ensuring no conflicts when multiple requests are made\n   * for the same file.\n   *\n   * @param args The arguments used to determine the file's identity and generation\n   * @returns The path to the cached or newly created file\n   */\n  async getFile(args: T): Promise<FilePath> {\n    const filePath = await this.resolveFilePath(args);\n\n    try {\n      await Promise.all([\n        this._cleanupGroupSemaphore.acquire(\"getFile\"),\n        this._semaphore.acquire(filePath),\n      ]);\n\n      if (await pathExists(filePath)) {\n        // fire and forget\n        touch(filePath);\n      } else {\n        await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n        await this._cb(filePath, args, this);\n      }\n    } finally {\n      this._semaphore.release(filePath);\n      this._cleanupGroupSemaphore.release(\"getFile\");\n    }\n\n    return filePath;\n  }\n\n  /**\n   * Resolves the full file path for the cached file based on the provided arguments.\n   *\n   * @param args The arguments used to resolve the file path\n   * @returns The full path to the cached file\n   */\n  async resolveFilePath(args: T): Promise<FilePath> {\n    const fileName = await this.resolveFileName(args);\n\n    const filePath = path.resolve(\n      this._cachePath,\n      fileName[0]!,\n      fileName[1]!,\n      fileName[2]!,\n      fileName,\n    );\n\n    return filePath;\n  }\n\n  /**\n   * Stops the background cleanup process, but does not delete any cached files.\n   */\n  destroy() {\n    if (this._intervalId) {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n    }\n  }\n\n  async has(args: T): Promise<boolean> {\n    const filePath = await this.resolveFilePath(args);\n    return await pathExists(filePath);\n  }\n\n  /**\n   * Runs a cleanup pass to remove files older than 1 day from the cache.\n   * This is called periodically, but can be triggered manually.\n   */\n  async cleanup() {\n    try {\n      await this._cleanupGroupSemaphore.acquire(\"cleanup\");\n      await findNuke(this._cachePath, {\n        olderThan: this._ttl,\n        verbose: true,\n        deleteEmptyDirectories: true,\n      });\n    } finally {\n      this._cleanupGroupSemaphore.release(\"cleanup\");\n    }\n  }\n}\n\nexport { type DirectoryPath, FileCache, type FileName, type FilePath };\n"],"mappings":"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","names":[]}